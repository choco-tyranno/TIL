# Process

+ 보조 기억장치(하드나 SSD)에 존재하는 명령어와 정적인 데이터 묶음인 `프로그램`이 메모리에 올라가면 프로세스가 됨.
  -> 프로세스란 실행중인 프로그램.
+ CPU(프로세서)는 한순간에 하나의 프로세스만을 실행할 수 있음.
+ 프로세스 여러개가 동시에 실행될 수 있는 것은 OS가 CPU가 실행할 프로세스들을 빠르게 교체하기 때문.

## 프로세스 구성

***

+  프로세스에 대한 정보는 프로세스 제어 블록(PCB : Process Confrol Block) 또는 프로세스 기술자(Process descriptor)라고 부르는 자료구조에 저장됨. 

+ 이 자료구조가 담고 있는 정보들은 크게 :

  * PID

    > PID, Process IDentification. 운영체제가 각 프로세스를 식별하기 위해 만든 식별자.

  * 프로세스 상태

    > CPU는 빠르게 프로세스를 스위칭하면서 실행시키기 때문에 그 중에는 실행중인 프로세스도, 대기중인 프로세스도 있다.

  * 프로그램 카운터

    > CPU가 다음으로 실행할 명령어를 가르키는 값. CPU는 기계어를 한 단위씩 읽어서 처리하는데 프로세스를 실행하기 위해 다음으로 실행할 기계어가 저장된 메모리 주소를 가르키는 값이다.

  * 스케쥴링 우선순위

    > 운영체제가 CPU에서 실행되는 순서를 결정하는 것이 스케쥴링. 우선순위가 높으면 우선 실행될 수 있다. 스케쥴링 우선순위.

  * 권한

    > 프로세스가 접근할 수 있는 자원을 결정하는 정보.

  * 프로세스의 부모/자식 프로세스

    > 최초로 생성되는 init 프로세스를 제외하고는 모두 부모 프로세스를 복제해서 생성되고 트리형태를 계층관계를 형성. 
    >
    > 각 프로세스는 부모와 자식 프로세스에 대한 정보를 가지고 있음.

  * 프로세스의 데이터와 명령어가 있는 메모리 위치를 가르키는 포인터

    > 프로세스가 메모리에 가지는 주소공간에 프로그램에 대한 정보가 있음.
    >
    > 이 주소공간에 대한 포인터 값을 가짐. 

  * 프로세스에 할당된 자원들을 가르키는 포인터

  * 실행 컨텍스트

    > 프로세스가 실행상태에서 마지막으로 실행한 프로세서의 레지스터 내용을 담고 있음.
    >
    > 프로세스가 다시 차례가 되어 실행될 때, 중단된 적이 없고 마치 연속적으로 실행된 것처럼하기 위해 이 레지스터 정보를 담고 있음.





## 프로세스가 접근할 수 있는 메모리 공간

***

프로세스의 데이터와 명령어가 있는 메모리의 구성 : 

<img src="https://t1.daumcdn.net/cfile/tistory/2453685056EEACBE22"/>

<p align="center"> 프로세스의 메모리 공간</p>

>  Stack영역과 Heap영역 사이의 빈공간은 컴파일 타임에 지역변수가 미리 계산될 수 없기 때문에,
>
> 런타임에 지역변수 선언순서에 따라 Stack영역은 위쪽으로 주소값을 매기고, 동적 할당될 때 Heap영역은 아래쪽으로 주소값을 매김.





## 프로세스 관리

***

+ 운영체제는 프로세스를 교체함에 있어 재시작되는 프로세스가 오류가 발생하지 않도록 관리해야함.
+ 이를 위해 운영체제는 프로세스 상태를 `실행(running)`, `준비(ready)`, `블록(block)` 상태로 분류하고 프로세스들을 상태전이(State transition)를 통해 체계적으로 관리함.

<img src="https://t1.daumcdn.net/cfile/tistory/27733D4856EEACF616"/>

<p align="center">프로세스 상태 전이</p>

> 1. 사용자가 프로그램을 실행하면 프로세스가 생성되고 준비리스트에 추가됨.
>
> 2. 프로세스는 CPU가 사용가능한 상태가 되면 CPU를 할당받음. 이를 `준비`상태에서 `실행`상태로 `상태전이`된다고 한다.
>
> 3. 이 과정을 디스패칭이라고 하고 디스패쳐가 수행함.
>
> 4. 프로세스는 실행상태에서 CPU를 이용해 연산한 후 CPU를 자발적으로 반납하고, 작업이 끝나지 않았으면 다시 준비상태로 돌아감.
>
> 5. 운영체제는 다시 준비리스트의 첫 번째에 있는 프로세스를 실행상태로 바꾸고 이 과정을 반복함.
>
>    > 운영체제는 프로세스가 CPU를 자발적으로 반납하지 않고 독점하는 경우를 방지하기 위해 하드웨어적으로 `인터럽팅 클록`을 주기적으로 발생시켜 프로세스가 `특정 시간 간격동안`만 실행할 수 있도록 함. 인터럽팅 클록이 발생되면 강제로 실행중인 프로세스의 CPU제어권을 운영체제에게 빼앗기고 프로세스는 준비상태로 상태 전이됨.
>
> 6. 만약 프로세스를 다시 사용하기 전에 입출력이 완료대기를 기다려야 하는 상황이라면 완료될 때까지 자신을 `블록`함. 입출력이 완료되면 운영체제가 프로세스를 블록상태에서 준비상태로 다시 전이 시킴.
>
> 많은 운영체제에서 일시정지 상태를 추가로 정의함. 이 상태 덕분에 디버깅을 편리하게 할 수 있게 됨.



참고 :

> blog : https://bowbowbow.tistory.com/16
>
> book : Operating Systems Three Easy Pieces, Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau, Arpaci-Dusseau Books, 2015
>
> 운영체제론, 송정희 옮김, 한빛미디어(2009)



