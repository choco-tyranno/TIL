# Better performance through threading

## 메인 스레드

+ Android는 사용자가 앱을 실행하면 실행 스레드와 함께 새로운 Linix프로세스를 만듬.
  이 메인 스레드는 UI스레드라고도 함. 화면에서 발생하는 모든 작업 담당.
+ 메인 스레드의 디자인 : 
  앱이 종료될 때까지 thread-safe work queue에서 작업 블록을 가져와서 실행시키는 것.
  프레임워크는 다양한 곳(라이프사이클 정보와 관련된 콜백들, 입력과 같은 사용자 이벤트, 타 앱이나 프로세스들로부터의 이벤트)에서 이러한 작업블록을 생성함.
   또한 앱은 프레임워크 사용 없이 스스로에게 명시적 방법으로 작업블록을 추가할 수 있다.
+ 애니메이션이나 화면 업데이트가 발생하는 동안 시스템은 초당 60프레임으로 매끄러운 렌더링을 하기 위해 약 16밀리초마다 작업 블록(화면 그리기)을 실행하려고 함.
  메인 스레드의 메시징 큐에 작업이 너무 많거나 긴 경우에는 16밀리초 이내에 작업 블록 실행을 완료할 수 없고 이는 화면 끊김, 지연, 입력에 대한 UI응답성 떨어짐, ANR(5초 이상 메인 스레드가 차단되는 경우)이 나타날 수 있다.
+ 앱에서 스레딩을 채택해야하는 가장 큰 이유는 메인 스레드로부터 많은, 긴 작업을 다른 스레드로 이동해 원활한 렌더링과 사용자 입력에 대한 빠른 응답성을 달성하고자 하는 것.

## 스레드와 UI 객체 참조

+ Android 뷰 객체는 thread-safe하지 않게 디자인된다.
+ 앱에서의 모든 UI 객체 생성 및 사용, 제거가 메인스레드에서 일어날 것이라고 기대된다.
  UI객체를 메인 스레드가 아닌 스레드에서 수정하고자 하면 예외, 자동 실패, 비정상 종료, 기타 정의되지 않은 오동작이 발생할 수 있음.

### 명시적 참조 : UI컨트롤러 레퍼런스 및 View(UI컨트롤러 참조를 포함)를 스레딩하는 경우 

+ 가비지 컬렉터가 닫힌 UI컨트롤러 등을 수집하지 못할 수 있음. 
+ 결과가 불안정해질 수 있음.
+ 결과가 정의되지 않을 수 있음.
+ 메모리가 낭비될 수 있음(중복 생성 등).
+ 메모리 누수와 스레딩 경합을 피하기 위해 명시적 참조를 피할 것.
+ 메인 스레드에선 UI객체 업데이트만을 담당하고, 다른 스레드와의 교류 정책을 만들어야 함.

### 암시적 참조 :  UI컨트롤러 레퍼런스 등 요소를 enclosing 클래스로 하는 비정적 내부 클래스의 경우

+ enclosing클래스 인스턴스에의 접근성을 만드는 비정적 내부 클래스 작성을 피해야 함.
+ 정적 중첩 클래스나 독립된 클래스로 정의하는 것을 권장.

## 스레드와 앱 액티비티 라이프사이클

+ 앱 라이프사이클은 어플리케이션에서 스레딩이 작동하는 방식이 영향을 주기도 함.
+ 액티비티 제거와 스레드 지속 여부와의 관계를 고려할 필요가 있음.
+ 스레드 우선순위 지정과 포그라운드/백그라운드에서의 액티비티  실행 여부 사이의 관계도 알아야 함.

### 스레드 지속 

+ 일반적으로 스레드는 스레드를 생성한 액티비티의 라이프사이클과는 무관하게 계속해서 지속됨.
+ 스레드는 UI와 관련한 작업을 해당 UI컨트롤러가 더이상 존재하지 않는 경우에도 지속할 필요가 없음.
+ 반면 UI컨트롤러 닫힘와 관련 없이 작업의 완료가 필요한 경우에는 작업이 여전히 유지되는 것이 타당함.
+   ViewModel과 LiveData를 사용하면 UI컨트롤러의 라이프사이클을 신경쓰지 않고도 데이터를 로드 및 데이터 변경 알림을 받을 수 있음.

### 스레드 우선순위

+ 앱의 스레드가 수신하는 우선순위는 앱 라이프사이클에서 앱의 위치에 따라 부분적으로 달라짐.

+ 애플리케이션에서 스레드를 만들고 관리할 때 적절한 우선순위 설정이 중요함.
  우선순위가 너무 높으면 해당 스레드가 UI스레드와 렌더스레드를 중단할 수 있음.
  너무 늦으면 필요한 속도보다 느리게 실행될 수 있음.

+ 일반적으로 스레드를 만들 때마다 setThreadPriority()를 호출해야 함.

+ 시스템의 스레드 스케줄러는 우선순위가 높은 스레드를 우선시하고, 우선순위는 최종적으로 모든 작업을 완수해야 할 필요성 사이에서 균형을 유지함.
  (일반적으로 기기에서 총 실행시간의 약 95%를 포그라운드 그룹의 스레드가, 5%를 백그라운드 그룹이 얻음)

+ 시스템은 Process 클래스를 사용해 각 스레드에 자체 우선순위 값을 할당.

+ 기본적으로 시스템은 스레드의 우선순위를 생성 스레드와 동일한 우선순위 및 그룹 멤버십으로 설정.

+ 애플리케이션은 setThreadPriority()를 통해 스레드 우선순위를 명시적으로 조정할 수 있음.

+ Process클래스는 앱이 스레드 우선순위를 설정하는 데 사용할 수 있는 상수 세트를 제공해 우선순위 값을 할당하는 작업의 복잡성을 줄이는 데 도움이 됨.

  > THREAD_PRIORITY_DEFAULT : 스레드 기본 값
  >
  > THREAD_PRIORITY_BACKGROUND : 덜 급한 작업을 실행하는 경우 이 우선순위 사용.
  >
  > THREAD_PRIORITY_LESS_FAVORABLE 및 THREAD_PRIORITY_MORE_FAVORABLE 상수를 사용해 상대적 우선순위 설정 가능.
  >
  > 스레드 우선순위 목록은 [THREAD_PRIORITY](https://developer.android.com/reference/android/os/Process#THREAD_PRIORITY_AUDIO) 상수 참조

## 스레딩을 위한 도우미 클래스

+ 코루틴 권장. 코루틴은 콜백들이 없는 비동기 코드, 범위지정/취소/에러 처리를 위한 구조화된 동시성을 제공함. 
+ 프레임워크는 자바 클래스와 프리미티브들로도 스레딩을 가능하도록 `Thead`,`Runnable`,`Executors`,`HandlerThread` 등 클래스들을 제공.

### ~~AsyncTask 클래스~~

### HandlerThread 클래스

+ Handler thread는 효과적으로 큐에서 작업을 가져와 작동하는 장기실행 스레드.
+ 예 : Camera.open() 호출을 핸들러 스레드 작업블록에에 위임하면 연결된 onPreviewFrame() 콜백이 UI스레드가 아닌 핸들러 스레드에 도달함. 픽셀에 대한 장기 작업 수행이 필요한 경우 권장됨.
+ ⚠️ caution : 앱이 HandlerThread를 사용해 스레드를 생성할 때 작업 유형에 따른 스레드의 우선순위 설정을 잊지말것. 우선순위 설정은 다른 스레드들이 경쟁할 때 시스템이 작업을 스케쥴할 적절한 방법을 알 수 있게 도움.
+ CPU는 적은 수의 스레드만 병렬로 운용가능함.

### ThreadPoolExecutor 클래스

+ 작업을 줄이는 데 고도 병렬화 분산 작업이 필요한 경우(예 : 8mb pixel 이미지의 각 8x8 블록에 대한 필터를 계산하는 작업) 권장.
  (HandlerThread는 작업 패킷의 양이 많기 때문에 적절하지 않음)
+ ThreadPollExecutor는 스레드 그룹을 만들고, 우선순위를 설정하고, 작업 분산 방식을 관리함.
  또한 워크로드가 늘거나 줄면 워크로드를 조정하기 위해 스레드들을 없애거나 돌림.
+ 최적의 스레드 수를 생성하는 데에도 도움됨. ThreadPoolExecutor 객체 생성시 최소 및 최대 스레드 수를 설정.

## 스레드를 얼마나 만들어야하는가?

+  소프트웨어 레벨에서 수백 개 의 스레드를 만들 수도 있지만, 성능 문제가 발생함.
  앱은 백그라운드 서비스, 렌더러, 오디오 엔진, 네트워킹 등 제한된 CPU 리소스를 공유.
  CPU는 적은 수의 스레드만을 병렬로 처리 가능.
  이와 같은 우선 순위 및 스케쥴링의 제한사항에 따라 워크로드에 필요한 만큼만 스레드를 생성하는 것이 중요함.
+ 많은 변수가 있겠지만, 4와 같은 값을 정해서 선택하고 Systrace로 테스트하면서 최소 스레드 수를 찾는 것이 하나의 확고한 전략임.
+ 스레드는 최소 64k의 메모리를 사용함. 이는 많은 앱들이 기기에 설치되는 상황에서 호출 스텍이 크게 증가함과 함께 메모리 사용량이 빠르게 증가될 수 있음.
+ 많은 시스템 프로세스와 서드파티 라이브러리들은 자체 스레드풀을 가동하기도 함. 이 재사용은 메모리 와 프로세싱 리소스 경합을 줄여 퍼포먼스 향상에 도움이 될 수 있음.

 

















